-- |
-- Module: Rules
--
-- This module defines an API for fine-grained rules, e.g. pre-build rules
-- for generating source Haskell modules.
--
-- Rules are allowed to depend on source files (e.g. a source @.x@ file),
-- as well as on the output of other rules.
--
module Rules
  ( -- * Rules
    -- ** Rule
    Rule(..), RuleId(..)

    -- ** Rule inputs/outputs
  , Dependency(..), Result(..)

   -- ** Collections of rules
  , Rules(..), PreBuildRules

  -- * Actions
  , Action(..), ActionId(..), ResolvedLocation

  -- * Rules API
  , ActionsM, RulesT
  , registerRule, registerAction

  -- ** Local name generation (for t'RuleId' and t'ActionId')
  , FreshT, runFreshT, hoist

  -- ** Placeholders (for the design phase)
  , SmallIO(..), BigIO(..)

  -- ** Debugging
  , getRules
  )
  where

-- base
import Control.Monad.Fix
  ( MonadFix )
import Data.Functor.Identity
  ( Identity(..) )
import Data.Word
  ( Word64 )
import GHC.Generics
  ( Generic )

-- binary
import Data.Binary
  ( Binary )

-- containers
import Data.Map.Strict
  ( Map )
import qualified Data.Map.Strict as Map
  ( empty, insert, lookupMax )

-- transformers
import Control.Monad.Trans.Class
  ( MonadTrans(..) )
import Control.Monad.Trans.State.Strict
  ( StateT(..), get, put )

-- john-rules
import CabalStubs
  ( PreBuildComponentInputs )

--------------------------------------------------------------------------------

-- | A unique identifier for a 'Rule'.
newtype RuleId = RuleId Word64
  deriving stock Show
  deriving newtype ( Eq, Ord, Binary )

-- | A unique identifier for an t'Action'.
newtype ActionId = ActionId Word64
  deriving stock Show
  deriving newtype ( Eq, Ord, Binary )

-- | A rule consists of:
--
--   - its dependencies (which specifies when the rule should be re-run);
--     see t'Dependency';
--   - a description of what kind of results it will produce (see t'Result');
--   - the t'Action' to run to execute the rule, referenced by t'ActionId'.
--
-- Each 'Dependency' will get resolved to the build system into a
-- 'ResolvedLocation', and these will be passed as additional arguments to the
-- action.
--
-- **Requirements:** the t'Action' whose t'ActionId' is stored in the 'actionId'
-- field of a 'Rule' must satisfy the following requirements:
--
--   - the t'Action' expects exactly as many 'ResolvedLocation' arguments
--     as there are 'Dependency' values stored in the 'dependencies'
--     field of the 'Rule's;
--   - the execution of an action must produce precisely the 'Result's
--     specified by the 'results' field of the 'Rule'.
data Rule = Rule
  { dependencies :: ![ Dependency ]
     -- ^ Dependencies of this rule; see t'Dependency'.
  , results :: ![ Result ]
     -- ^ Results of this rule; see t'Result'.
  , actionId :: !ActionId
     -- ^ To run this rule, which t'Action' should we execute?
     --
     -- The t'Action' will receive exactly as many 'ResolvedLocation'
     -- arguments as there are 'Dependency' values stored in 'dependencies'.
  }
  deriving stock ( Generic, Show )
  deriving anyclass Binary

-- | A dependency of a rule, which specifies when to re-run the rule.
data Dependency
  -- | Declare a dependency on a source file from the current project,
  -- e.g. the path to a Happy @.y@ file from the project.
  --
  -- This file might exist already, or it might be the output of another rule.
  = ProjectFile !FilePath
    -- ^ relative path from a Cabal search directory,
    -- such as a source directory for the component or
    -- a directory for autogenerated modules for the component.
  deriving stock ( Generic, Show )
  deriving anyclass Binary

-- | A resolved location of a dependency or result of a rule, consisting
-- of a base path and of a file path relative to that base path.
--
-- In practice, this will be something like @( dir, toFilePath modName )@,
-- where:
--
--  - for a dependency, @dir@ is one of the Cabal search directories,
--  - for an output, @dir@ is a directory such as @autogenComponentModulesDir@
--    or @componentBuildDir@.
type ResolvedLocation = ( FilePath, FilePath )
  -- The reason for splitting it up this way is that some pre-processors don't
  -- simply generate one output @.hs@ file from one input file, but have
  -- dependencies on other generated files (notably @c2hs@, where building one
  -- @.hs@ file may require reading other @.chi@ files, and then compiling the
  -- @.hs@ file may require reading a generated @.h@ file).
  -- In these cases, the generated files need to embed relative path names to each
  -- other (eg the generated @.hs@ file mentions the @.h@ file in the FFI imports).
  -- This path must be relative to the base directory where the generated files
  -- are located; it cannot be relative to the top level of the build tree because
  -- the compilers do not look for @.h@ files relative to there, ie we do not use
  -- @-I .@, instead we use @-I dist/build@ (or whatever dist dir has been set
  -- by the user).

-- | A description of the location of a file generated by executing a rule.
data Result
  -- | Generates a file with the given relative filepath;
  -- Cabal should resolve the location to some 'componentAutogenModules'
  -- directory.
  = AutogenFile !FilePath
  -- | Generates a file with the given relative filepath,
  -- Cabal should resolve the location to some 'componentBuildDir' directory.
  | BuildFile !FilePath
  deriving stock ( Generic, Show )
  deriving anyclass Binary

-- | An action to run to execute a 'Rule', for example an invocation
-- to an external executable such as @happy@ or @alex@.
--
-- The t'action' function gets passed precisely as many 'ResolvedLocation'
-- values as there are 'Dependency' values declared in the 'Rule' that calls it.
--
-- **Requirement:** outputs of this action should be put in the locations
-- specified by the second argument, which are in one-to-one correspondence
-- with the 'Result's stored in the 'Rule' that stored the t'ActionId'
-- that refers to this t'Action'.
data Action =
  Action
    { action
      :: [ ResolvedLocation ]
           -- ^ locations of the dependencies of this action,
           -- as declared by the rule that this action is executing
      -> [ ResolvedLocation ]
           -- ^ expected locations of the results of this action,
           -- as declared by the rule that this action is executing
      -> BigIO () }

-- | A collection of 'Rule's and 'Actions' for executing them.
--
-- The @inputs@ type parameter represents an extra argument, which usually
-- consists of information known to Cabal such as 'LocalBuildInfo' and
-- 'ComponentLocalBuildInfo'.
--
-- The @outputs@ type parameter represents what the rules are generating,
-- for example a map from Haskell source module to the 'Rule' that generates it.
--
-- Actions are registered using 'registerAction', and rules are registered
-- using 'registerRule'. Even though 'Rule's and t'Action's are registered
-- separately, they must jointly satisfy the following preconditions
-- (see t'Rule'):
--
--  - the action called by a rule should expect as many arguments as
--    the rule declares dependencies;
--  - the action called by a rule should output the results described by
--    the rule.
data Rules inputs outputs
  = Rules
  { rules :: inputs -> ActionsM ( RulesT SmallIO outputs ) }
    -- ^ Return a collection of t'Action's and their t'ActionId's, and then,
    -- in the inner computation, a collection of t'RuleId's, with each t'RuleId'
    -- associated with a corresponding 'Rule' which specifies its dependencies
    -- as well as the t'ActionId' of the t'Action' to run in order to execute
    -- the rule.
    --
    -- You can think of this type signature as:
    --
    -- > inputs -> ( Map ActionId Action, IO ( outputs, Map RuleId Rule ) )
    --
    -- except that it is structured in such a way as to avoid having
    -- to manually create t'ActionId' and t'RuleId' values.

instance Functor ( Rules inputs ) where
  fmap f ( Rules r ) = Rules \ inputs -> fmap ( fmap f ) ( r inputs )
instance Applicative ( Rules inputs ) where
  pure o = Rules \ _ -> pure ( pure o )
  ( Rules f ) <*> ( Rules a ) =
    Rules \ inputs ->
      liftA2 (<*>) ( f inputs ) ( a inputs )
-- NB: no Monad instance.

-- | Warning: this 'Semigroup' instance is not commutative.
instance Semigroup outputs => Semigroup ( Rules inputs outputs ) where
  ( Rules { rules = rs1 } ) <> ( Rules { rules = rs2 } ) =
    Rules
      { rules = \ inputs -> do
         x1 <- rs1 inputs
         x2 <- rs2 inputs
         return $ do
            y1 <- x1
            y2 <- x2
            return $ y1 <> y2 }

instance Monoid outputs => Monoid ( Rules inputs outputs ) where
  mempty = Rules { rules = \ _ -> pure $ pure mempty }

-- | A monad transformer for the registration of values, through the creation
-- of fresh identifiers for these values.
newtype FreshT x x_id m a = FreshT { freshT :: StateT ( Map x_id x ) m a }
  deriving newtype ( Functor, Applicative, Monad, MonadTrans, MonadFix )
runFreshT :: FreshT x x_id m a -> m ( a, Map x_id x )
runFreshT = ( `runStateT` Map.empty ) . freshT

type RulesT = FreshT Rule RuleId
type ActionsM = FreshT Action ActionId Identity

-- These newtypes are placeholders meant to help keep track of effects
-- during the design of the API.
newtype BigIO a = BigIO { runBigIO :: IO a }
  deriving newtype ( Functor, Applicative, Monad )
newtype SmallIO a = SmallIO { runSmallIO :: IO a }
  deriving newtype ( Functor, Applicative, Monad )

--------------------------------------------------------------------------------
-- Rules for the pre-build phase (preparing sources).

-- | PreBuildRules declare how a certain collection of modules in a
-- given component of a package will be generated.
type PreBuildRules = Rules PreBuildComponentInputs () -- ( Map ModuleName RuleId )

--------------------------------------------------------------------------------
-- API functions

hoist :: ( forall u. n u -> m u )
      -> FreshT x x_id n a -> FreshT x x_id m a
hoist h ( FreshT ( StateT f ) ) = FreshT $ StateT $ \ s -> h $ f s

register :: ( Monad m, Ord x_id )
         => x_id -> ( x_id -> x_id )
         -> x -> FreshT x x_id m x_id
register zeroId succId rule = FreshT do
  oldRules <- get
  let newId
        | Just ( x_id, _ ) <- Map.lookupMax oldRules
        = succId x_id
        | otherwise
        = zeroId
      !newRules = Map.insert newId rule oldRules
  put newRules
  return newId

-- | Register a rule. Returns a unique identifier for that rule.
registerRule :: Monad m => Rule -> FreshT Rule RuleId m RuleId
registerRule = register ( RuleId 1 ) ( \ ( RuleId i ) -> RuleId ( i + 1 ) )

-- | Register an action. Returns a unique identifier for that action.
registerAction :: Monad m => Action -> FreshT Action ActionId m ActionId
registerAction = register ( ActionId 1 ) ( \ ( ActionId i ) -> ActionId ( i + 1 ) )

{-# INLINABLE registerRule #-}
{-# INLINABLE registerAction #-}
{-# SPECIALISE
      registerRule :: Rule -> FreshT Rule RuleId SmallIO RuleId
  #-}
{-# SPECIALISE
      registerAction :: Action -> FreshT Action ActionId Identity ActionId
  #-}

-- | Convenience function to return all 'Rule's stored in 'Rules'.
--
-- Useful for debugging.
getRules :: inputs -> Rules inputs outputs -> IO ( outputs, Map RuleId Rule )
getRules inputs ( Rules { rules = rulesFromInputs } ) =
  runSmallIO $ runFreshT $ fst $ runIdentity $ runFreshT $ rulesFromInputs inputs
