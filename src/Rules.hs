-- |
-- Module: Rules
--
-- This module defines an API for fine-grained rules, e.g. pre-build rules
-- for generating source Haskell modules.
--
-- Rules are allowed to depend on source files (e.g. a source @.x@ file),
-- as well as on the output of other rules.
--
module Rules
  ( -- * Rules
    Rule(..), RuleId(..)

    -- ** Rule inputs/outputs
  , UnresolvedDependency(..), Result, Location(..)

   -- ** Collections of rules
  , Rules(..), PreBuildRules

  -- * Actions
  , Action(..), ActionFunction
  , ActionId(..), ResolvedLocation, ResolvedLocations(..)

  -- * Placeholders (for the design phase)
  , SmallIO(..), BigIO(..)

  )
  where

-- base
import Data.Word
  ( Word64 )
import GHC.Generics
  ( Generic )

-- binary
import Data.Binary
  ( Binary )
import qualified Data.Binary as Binary
  ( get, put )

-- bytestring
import qualified Data.ByteString.Lazy as Lazy
  ( ByteString )

-- containers
import Data.Map.Strict
  ( Map )
import qualified Data.Map.Strict as Map
  ( empty )

-- john-rules
import CabalStubs
  ( PreBuildComponentInputs )
import Monitor
  ( MonitorFileOrDir )

--------------------------------------------------------------------------------

-- | A unique identifier for a 'Rule'.
newtype RuleId = RuleId Word64
  deriving stock Show
  deriving newtype ( Eq, Ord, Binary )

-- | A unique identifier for an t'Action'.
newtype ActionId = ActionId Word64
  deriving stock Show
  deriving newtype ( Eq, Ord, Binary )

-- | A rule consists of:
--
--  - an action to run, indirectly referenced by the 'ActionId' of
--    the 'Action'
--  - a description of the action:
--    - what inputs the action depends on
--    - what outputs will result from the execution of the action
--
-- Each 'UnresolvedDependency' will get resolved by the build system into a
-- 'ResolvedLocation', and these will be passed as additional arguments to the
-- action.
--
-- **Requirements:** the t'Action' whose t'ActionId' is stored in the 'actionId'
-- field of a 'Rule' must satisfy the following requirements:
--
--   - the t'Action' expects exactly as many 'ResolvedLocation' arguments
--     as there are 'UnresolvedDependency' values stored in the
--     'unresolvedDependencies' field of the 'Rule's;
--   - the execution of an action must produce precisely the 'Result's
--     specified by the 'results' field of the 'Rule'.
data Rule = Rule
  { unresolvedDependencies :: ![ UnresolvedDependency ]
     -- ^ Unresolved dependencies of this rule; see t'UnresolvedDependency '.
     --
     -- When the build system executes the action associated to this rule,
     -- it will resolve these dependencies and pass them as an argument
     -- to the action, in the form of a @['ResolvedDependency']@.
  , monitoredValue :: !( Maybe Lazy.ByteString )
     -- ^ A monitored value. The rule should be re-run whenever this value
     -- changes.
     --
     -- Use this to declare a dependency on a certain projection of the
     -- environment passed to the rule.
     --
     -- A value of 'Nothing' means: always re-run the rule when the
     -- environment passes to it changes.
  , monitoredFiles :: ![ MonitorFileOrDir FilePath Location ]
     -- ^ Monitored files or directories; if these change in some way,
     -- the rule is considered out-of-date.
  , results :: ![ Result ]
     -- ^ Results of this rule; see t'Result'.
  , actionId :: !ActionId
     -- ^ To run this rule, which t'Action' should we execute?
     --
     -- The t'Action' will receive exactly as many 'ResolvedLocation'
     -- arguments as there are 'UnresolvedDependency' values stored in
     -- the 'unresolvedDependencies' field.
  }
  deriving stock ( Generic, Show )
  deriving anyclass Binary

-- | A dependency of a rule, which needs to be resolved by the build system
-- in some way.
data UnresolvedDependency
  -- | Declare a dependency on a file from the current project that should
  -- be found by looking at project search paths.
  --
  -- This file might exist already, or it might be the output of another rule.
  = ProjectSearchDirFile
      !Location
        -- ^ where to go looking for the file
      !FilePath
        -- ^ path of the file, relative to a Cabal search directory
  deriving stock ( Generic, Show )
  deriving anyclass Binary

-- | A description of the location of a file generated by executing a rule.
type Result = ( Location, FilePath )

-- | A description of the directory in which we expect a particular file to
-- be located, whether the file be an input or an output of a rule.
data Location
  -- | A source file:
  --
  -- - for a rule dependency, we will go looking for it in
  --   the source directories and in autogen modules directories;
  -- - for a rule output, the file should be put in an autogen module directory.
  = SrcFile
  -- | A build-file, that belongs to some build directory.
  | BuildFile
  deriving stock ( Generic, Show, Eq, Ord, Enum, Bounded )
  deriving anyclass Binary

-- | A resolved location of a dependency or result of a rule, consisting
-- of a base path and of a file path relative to that base path.
--
-- In practice, this will be something like @( dir, toFilePath modName )@,
-- where:
--
--  - for a dependency, @dir@ is one of the Cabal search directories,
--  - for an output, @dir@ is a directory such as @autogenComponentModulesDir@
--    or @componentBuildDir@.
type ResolvedLocation = ( FilePath, FilePath )
  -- The reason for splitting it up this way is that some pre-processors don't
  -- simply generate one output @.hs@ file from one input file, but have
  -- dependencies on other generated files (notably @c2hs@, where building one
  -- @.hs@ file may require reading other @.chi@ files, and then compiling the
  -- @.hs@ file may require reading a generated @.h@ file).
  -- In these cases, the generated files need to embed relative path names to each
  -- other (eg the generated @.hs@ file mentions the @.h@ file in the FFI imports).
  -- This path must be relative to the base directory where the generated files
  -- are located; it cannot be relative to the top level of the build tree because
  -- the compilers do not look for @.h@ files relative to there, ie we do not use
  -- @-I .@, instead we use @-I dist/build@ (or whatever dist dir has been set
  -- by the user).

newtype ResolvedLocations =
  ResolvedLocations { resolveLocation :: Location -> FilePath }
locations :: [Location]
locations = [ minBound .. maxBound ]
resolvedLocations :: ResolvedLocations -> [FilePath]
resolvedLocations (ResolvedLocations { resolveLocation = fn })
  = map fn locations

instance Show ResolvedLocations where
  show dirs = show $ resolvedLocations dirs
instance Eq ResolvedLocations where
  f == g = resolvedLocations f == resolvedLocations g
instance Ord ResolvedLocations where
  compare f g = compare (resolvedLocations f) (resolvedLocations g)
instance Binary ResolvedLocations where
  put f = mapM_ Binary.put $ resolvedLocations f
  get = do
    -- NB: be careful to ensure that the order here
    -- matches the Enum instance for 'ResultLocation'
    srcDir   <- Binary.get
    buildDir <- Binary.get
    return $ ResolvedLocations $ \ loc -> case loc of
      SrcFile   -> srcDir
      BuildFile -> buildDir

type ActionFunction =
  [ ResolvedLocation ]
           -- ^ locations of the dependencies of this action,
           -- as declared by the rule that this action is executing
      -> ResolvedLocations
           -- ^ directories in which the results of this action
           -- should be put

           -- API design note: this argument could instead have type
           -- [ ResolvedDependency ], and we would pass as many paths as
           -- the rule that this action is executing declares results,
           -- but that would mean that if the rule has many outputs,
           -- the action would need to be able to handle putting each of its
           -- outputs in a different directory. This is rather unergonomic,
           -- and it would require passing all these filepaths through the
           -- SetupHooks CLI interface.
      -> BigIO ()

-- | An action to run to execute a 'Rule', for example an invocation
-- to an external executable such as @happy@ or @alex@.
--
-- The t'action' function gets passed precisely as many 'ResolvedLocation'
-- values as there are 'UnresolvedDependency' values declared in the
-- 'Rule' that calls it.
--
-- **Requirement:** outputs of this action should be put in the locations
-- specified by the second argument.
data Action = Action { action :: ActionFunction }

-- | A collection of 'Rule's and 'Actions' for executing them.
--
-- The @env@ type parameter represents an extra argument, which usually
-- consists of information known to Cabal such as 'LocalBuildInfo' and
-- 'ComponentLocalBuildInfo'.
--
-- Even though 'Rule's and t'Action's are specified separately, they must
-- jointly satisfy the following preconditions (see t'Rule'):
--
--  - the action called by a rule should expect as many arguments as
--    the rule declares unresolved dependencies;
--  - the action called by a rule should output the results described by
--    the rule.
data Rules env
  = Rules
    { rules :: env -> SmallIO ( Map RuleId Rule )
       -- ^ The computation of all rules, with their dependency structure.
    , actions :: env -> Map ActionId Action
       -- ^ The actions that execute the rules.
    }

-- | Warning: this 'Semigroup' instance is not commutative.
instance Semigroup ( Rules env ) where
  ( Rules { rules = rs1, actions = as1 } ) <>
    ( Rules { rules = rs2, actions = as2 } ) =
    Rules
      { rules = \ inputs -> do
         x1 <- rs1 inputs
         x2 <- rs2 inputs
         return $ x1 <> x2
     , actions = \ inputs -> as1 inputs <> as2 inputs }

instance Monoid ( Rules env ) where
  mempty =
    Rules { rules = \ _ -> pure Map.empty
          , actions = \ _ -> Map.empty
          }

-- These newtypes are placeholders meant to help keep track of effects
-- during the design of the API.
newtype BigIO a = BigIO { runBigIO :: IO a }
  deriving newtype ( Functor, Applicative, Monad )
newtype SmallIO a = SmallIO { runSmallIO :: IO a }
  deriving newtype ( Functor, Applicative, Monad )

--------------------------------------------------------------------------------
-- Rules for the pre-build phase (preparing sources).

-- | PreBuildRules declare how a certain collection of modules in a
-- given component of a package will be generated.
type PreBuildRules = Rules PreBuildComponentInputs
