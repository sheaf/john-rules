-- |
-- Module: Rules
--
-- This module defines an API for fine-grained rules, e.g. pre-build rules
-- for generating source Haskell modules.
--
-- Rules are allowed to depend on source files (e.g. a source @.x@ file),
-- as well as on the output of other rules.
--
module Rules
  ( -- * Rules
    -- ** Rule
    Rule(..), RuleId(..), RuleResultRef(..)

    -- ** Rule inputs/outputs
  , Dependency(..), Result(..)

   -- ** Collections of rules
  , Rules(..), PreBuildRules

  -- * Actions
  , Action(..), ActionId(..), ResolvedDependency

  -- * Rules API
  , SmallIO(..), BigIO(..), FreshT
  , registerRule, runRulesM, liftFresh, hoist

  -- ** Debugging
  , getRules
  )
  where

-- base
import Control.Monad.Fix
  ( MonadFix )
import Data.Word
  ( Word64 )
import GHC.Generics
  ( Generic )

-- binary
import Data.Binary
  ( Binary )

-- containers
import Data.Map.Strict
  ( Map )
import qualified Data.Map.Strict as Map
  ( empty, insert, lookupMax )

-- transformers
import Control.Monad.IO.Class
  ( MonadIO )
import Control.Monad.Trans.Class
  ( MonadTrans )
import Control.Monad.Trans.State.Strict
  ( StateT(..), get, put )

-- john-rules
import CabalStubs
  ( ModuleName, PreBuildComponentInputs )

--------------------------------------------------------------------------------

-- | A unique identifier for a 'Rule'.
newtype RuleId = RuleId Word64
  deriving stock Show
  deriving newtype ( Eq, Ord, Binary )

-- | A unique identifier for an 'Action'.
newtype ActionId = ActionId Word64
  deriving stock Show
  deriving newtype ( Eq, Ord, Binary )

-- | A rule consists of:
--
--   - its dependencies (which specifies when the rule should be re-run);
--     see t'Dependency';
--   - a description of what kind of results it will produce (see t'Result');
--   - the 'Action' to run to execute the rule, referenced by 'ActionId'.
--
-- Each 'Dependency' will get resolved to the build system into a
-- 'ResolvedDependency', and these will be passed as additional arguments to the
-- action.
--
-- **Requirements:** the 'Action' whose 'ActionId' is stored in the 'actionId'
-- field of a 'Rule' must satisfy the following requirements:
--
--   - the 'Action' expects exactly as many 'ResolvedDependency' arguments
--     as there are 'Dependency' values stored in the 'dependencies'
--     field of the 'Rule's;
--   - the action must produce precisely the 'Result's specified by the
--     'results' field of the 'Rule'.
data Rule = Rule
  { dependencies :: ![ Dependency ]
     -- ^ Dependencies of this rule; see t'Dependency'.
  , results :: ![ Result ]
     -- ^ Results of this rule; see t'Result'.
  , actionId :: !ActionId
     -- ^ To run this rule, which 'Action' should we execute?
     --
     -- The 'Action' will receive exactly as many 'ResolvedDependency'
     -- arguments as 'Dependency' values are stored in 'dependencies'.
  }
  deriving stock ( Generic, Show )
  deriving anyclass Binary

-- | A dependency of a rule, which specifies when to re-run the rule.
--
-- Rules can depend either on a source file, or on the output of another rule.
--
-- A 'Dependency' gets resolved into a 'ResolvedDependency' by the build system.
data Dependency
  -- | Declare a dependency on a source file from the current project,
  -- e.g. the path to a Happy @.y@ file from the project.
  = ProjectFile !FilePath
    -- ^ relative path from a Cabal search directory,
    -- e.g. one of the listed source directories or
    -- an autogenerated-modules directory
  -- | Declare a dependency on an output of another rule.
  | RuleResult !RuleResultRef
  deriving stock ( Generic, Show )
  deriving anyclass Binary

-- | A resolved dependency, consisting of a base path and of
-- a file path relative to that base path.
--
-- In practice, this will be something like @( srcDir, toFilePath modName )@,
-- where @srcDir@ is one of the Cabal search directories.
type ResolvedDependency = ( FilePath, FilePath )
  -- The reason for splitting it up this way is that some pre-processors don't
  -- simply generate one output @.hs@ file from one input file, but have
  -- dependencies on other generated files (notably @c2hs@, where building one
  -- @.hs@ file may require reading other @.chi@ files, and then compiling the
  -- @.hs@ file may require reading a generated @.h@ file).
  -- In these cases, the generated files need to embed relative path names to each
  -- other (eg the generated @.hs@ file mentions the @.h@ file in the FFI imports).
  -- This path must be relative to the base directory where the generated files
  -- are located; it cannot be relative to the top level of the build tree because
  -- the compilers do not look for @.h@ files relative to there, ie we do not use
  -- @-I .@, instead we use @-I dist/build@ (or whatever dist dir has been set
  -- by the user).

-- | A description of the location of the file generated by executing a rule.
data Result
  -- | Generates a file with the given relative filepath,
  -- relative to the 'componentAutogenModules' directory.
  = AutogenFile !FilePath
  -- | Generates a file with the given relative filepath,
  -- relative to the 'componentBuildDir' directory.
  | BuildFile !FilePath
  deriving stock ( Generic, Show )
  deriving anyclass Binary

-- | A reference to the output of another rule.
data RuleResultRef =
  RuleResultRef
    { ruleId :: !RuleId
      -- ^ Which rule?
    , ruleResultIndex :: !Word
      -- ^ Which output of that rule? (@0@-indexed)
    }
  deriving stock ( Generic, Show )
  deriving anyclass Binary

-- | An action to run to execute a 'Rule', for example an invocation
-- to an external executable such as @happy@ or @alex@.
--
-- The 'Action' gets passed precisely as many 'ResolvedDependency' values
-- as the 'Rule' that calls it specifies 'Dependency' values.
--
-- **Requirement:** outputs of this action should be put in either
-- @autogenComponentModulesDir@ or @componentBuildDir@, as specified by the
-- 'Result's stored in the 'Rule' that stored the 'ActionId' that refers to
-- this 'Action'.
data Action =
  Action
    { action :: [ ResolvedDependency ] -> BigIO () }

-- | A collection of 'Rule's and 'Actions' for executing them.
--
-- The @inputs@ type parameter represents an extra argument, which usually
-- consists of information known to Cabal such as 'LocalBuildInfo' and
-- 'ComponentLocalBuildInfo'.
--
-- The @outputs@ type parameter represents what the rules are generating,
-- for example a map from Haskell source module to the 'Rule' that generates it.
--
-- Even though 'Rule's and 'Action's are specified separately, they must jointly
-- satisfy some preconditions (see t'Rule'):
--
--  - the action called by a rule should expect as many arguments as
--    the rule declares dependencies;
--  - the action called by a rule should output the results described by
--    the rule.
data Rules inputs outputs
  = Rules
  { rules :: inputs -> RulesM outputs
    -- ^ The rules: a collection of 'RuleId's, and for each 'RuleId'
    -- a corresponding 'Rule' which specifies its dependencies and
    -- the action to run in order to execute the rule.
  , actions :: inputs -> Map ActionId Action
    -- ^ All actions that we can execute. For example, one action could
    -- be running @happy@, another running @alex@.
  }

-- | A monad that allows registering 'Rule's using 'registerRule',
-- through the creation of fresh 'RuleId's.
newtype FreshT m a = FreshT { runFreshT :: StateT ( Map RuleId Rule ) m a }
  deriving newtype ( Functor, Applicative, Monad, MonadTrans, MonadIO, MonadFix )
type RulesM = FreshT SmallIO

-- These newtypes are placeholders meant to help keep track of effects
-- during the design of the API.
newtype BigIO a = BigIO { runBigIO :: IO a }
  deriving newtype ( Functor, Applicative, Monad )
newtype SmallIO a = SmallIO { runSmallIO :: IO a }
  deriving newtype ( Functor, Applicative, Monad )

runRulesM :: FreshT m a -> m ( a, Map RuleId Rule )
runRulesM = ( `runStateT` Map.empty ) . runFreshT

-- | Convenience function to return all 'Rule's stored in 'Rules'.
--
-- Useful for debugging.
getRules :: inputs -> Rules inputs outputs -> IO ( outputs, Map RuleId Rule )
getRules inputs ( Rules { rules = rulesFromInputs } ) =
  runSmallIO $ runRulesM $ rulesFromInputs inputs

{- TODO: don't let users create the ActionIds themselves.

Currently, users obtain 'RuleId's by using registerRule. This works nicely
and means rules don't have to be self-aware.

It would be nice to do the same thing with 'ActionId's. The problem is that
we need to refer to the 'ActionId's in the 'rules' field of 'Rules', but
they would be computed in the monad for the 'actions' field.
-}

--------------------------------------------------------------------------------
-- Rules for the pre-build phase (preparing sources).

-- | PreBuildRules declare how a certain collection of modules in a
-- given component of a package will be generated.
type PreBuildRules = Rules PreBuildComponentInputs ( Map ModuleName RuleId )
  -- TODO: what if we want a rule to generate an @hs-boot@ file?

--------------------------------------------------------------------------------
-- API functions

liftFresh :: Functor m => m a -> FreshT m a
liftFresh f = FreshT $ StateT $ \ s -> ( , s ) <$> f

hoist :: ( forall x. n x -> m x )
      -> FreshT n a -> FreshT m a
hoist h ( FreshT ( StateT f ) ) = FreshT $ StateT $ \ s -> h $ f s

registerRule :: Monad m => Rule -> FreshT m RuleId
registerRule rule = do
  oldRules <- FreshT get
  let newId
        | Just ( RuleId i, _ ) <- Map.lookupMax oldRules
        = RuleId ( i + 1)
        | otherwise
        = RuleId 1
      !newRules = Map.insert newId rule oldRules
  FreshT $ put newRules
  return newId
