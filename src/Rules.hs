module Rules where

-- base
import Data.Foldable
  ( for_ )
import Data.Maybe
  ( listToMaybe, mapMaybe )
import Data.Word
  ( Word64 )
import GHC.Generics
  ( Generic )
import System.Environment
  ( getArgs )

-- binary
import Data.Binary
  ( Binary )
import qualified Data.Binary as Binary
  ( encode, decode )

-- bytestring
import qualified Data.ByteString.Lazy as LBS
  ( getContents, putStr )

-- containers
import qualified Data.Graph as Graph
import Data.Map.Strict
  ( Map )
import qualified Data.Map.Strict as Map
  ( assocs, empty, insert, lookup, lookupMax )

-- transformers
import Control.Monad.Trans.State.Strict
  ( StateT(..), get, put )

-- john-rules
import CabalStubs
  ( ModuleName, PreBuildComponentInputs )

--------------------------------------------------------------------------------

-- | A unique identifier for a 'Rule'.
newtype RuleId = RuleId Word64
  deriving stock Show
  deriving newtype ( Eq, Ord, Binary )

-- | A unique identifier for an 'Action'.
newtype ActionId = ActionId Word64
  deriving stock Show
  deriving newtype ( Eq, Ord, Binary )

-- | A rule consists of:
--
--   - its dependencies (which specifies when the rule should be re-run);
--     see t'Dependency';
--   - the 'Action' to run to execute the rule, referenced by 'ActionId'
--   - additional data that the 'Action' needs to be given.
data Rule = Rule
  { dependencies :: ![ Dependency ]
     -- ^ dependencies of this rule; see t'Dependency'
  , results :: ![ Result ]
     -- ^ results of this rule; see t'Result'
  , actionId :: !ActionId
     -- ^ to run this rule, which 'Action' should we execute?
  }
  deriving stock ( Generic, Show )
  deriving anyclass Binary

-- | A dependency of a rule, which specifies when to re-run the rule.
--
-- Rules can depend either on a source file, or the output of another rule.
data Dependency
  -- | Declare a dependency on a source file from the current project,
  -- e.g. the path to a Happy @.y@ file from the project.
  = ProjectFile !FilePath
    -- ^ relative path from a Cabal search directory,
    -- e.g. one of the listed source directories or
    -- an autogenerated-modules directory
  -- | Declare a dependency on an output of another rule.
  | RuleResult !RuleResultRef
  deriving stock ( Generic, Show )
  deriving anyclass Binary

type ResolvedDependency = (FilePath, FilePath)

-- | A description of the location of the file generated by executing a rule.
data Result
  -- | Generates a file with the given relative filepath,
  -- relative to the 'componentAutogenModules' directory.
  = AutogenFile !FilePath
  -- | Generates a file with the given relative filepath,
  -- relative to the 'componentBuildDir' directory.
  | BuildFile !FilePath
  deriving stock ( Generic, Show )
  deriving anyclass Binary

-- | A reference to the output of another rule.
data RuleResultRef =
  RuleResultRef
    { ruleId :: !RuleId
      -- ^ Which rule?
    , ruleResultIndex :: !Word
      -- ^ Which output of that rule? (@0@-indexed)
    }
  deriving stock ( Generic, Show )
  deriving anyclass Binary

-- | An action to run to execute a 'Rule', for example an invocation
-- to an external executable such as @happy@ or @alex@.
--
-- The additional argument is used to specify information that depends on
-- the particular rule being run, for example the module name being compiled.
data Action =
  Action
    { action :: [ResolvedDependency] -> BigIO () }
  -- Outputs of this action should be put in either autogenComponentModulesDir
  -- or componentBuildDir (modulo the "-tmp" issue),
  -- as specified by the 'Result's stored in the 'Rule' that stored
  -- the 'ActionId' that refers to this 'Action'.

-- | A collection of 'Rule's and 'Actions' for executing them.
--
-- The @inputs@ type parameter represents an extra argument, which usually
-- consists of information known to Cabal such as a 'LocalBuildInfo' and a
-- 'ComponentLocalBuildInfo'.
data Rules inputs outputs
  = Rules
  { actions :: inputs -> Map ActionId Action
    -- ^ All actions that we can execute. For example, one action could
    -- be running @happy@, another running @alex@.
  , rules :: inputs -> RulesM outputs
    -- ^ The rules: a collection of 'RuleId's, and for each 'RuleId'
    -- a corresponding 'Rule' which specifies its dependencies and
    -- the action to run in order to execute the rule.
  }

type FreshT = StateT ( Map RuleId Rule )
type RulesM = FreshT SmallIO

-- These newtypes are placeholders meant to help keep track of effects
-- during the design of the API.
newtype BigIO a = BigIO { runBigIO :: IO a }
  deriving newtype ( Functor, Applicative, Monad )
newtype SmallIO a = SmallIO { runSmallIO :: IO a }
  deriving newtype ( Functor, Applicative, Monad )



runRulesM :: FreshT m a -> m ( a, Map RuleId Rule )
runRulesM = ( `runStateT` Map.empty )

{- TODO: don't let users create the ActionIds themselves.

Currently, users obtain 'RuleId's by using registerRule. This works nicely
and means rules don't have to be self-aware.

It would be nice to do the same thing with 'ActionId's. The problem is that
we need to refer to the 'ActionId's in the 'rules' field of 'Rules', but
they would be computed in the monad for the 'actions' field.
-}

--------------------------------------------------------------------------------
-- Rules for the pre-build phase (preparing sources).

-- | PreBuildRules declare how a certain collection of modules in a
-- given component of a package will be generated.
type PreBuildRules = Rules PreBuildComponentInputs ( Map ModuleName RuleId )

--------------------------------------------------------------------------------
-- External Hooks executable

-- | Create an executable which accepts the name of a hook as the argument,
-- then reads arguments to the hook over stdin and writes the results of the hook
-- to stdout.
hooksExecutable :: PreBuildRules -> IO ()
hooksExecutable preBuildRules = do
  args <- getArgs
  case args of
    [] -> error "hooksExecutable: missing argument"
    hookName:_ ->
      case hookName of
        "runPreBuildAction" ->
          -- Execute a pre-build action, given its ActionId and ActionArg.
          runHookHandle
            \ (cabalBuildInfoStuff, actId, actionArgData) -> do
            let allActions = actions preBuildRules cabalBuildInfoStuff
            case Map.lookup actId allActions of
              Nothing -> error $ "hooksExecutable: no such action " ++ show actId
              Just ( Action f ) ->
                runBigIO $ f ( Binary.decode actionArgData )
        "preBuildRules" ->
          -- Query all pre-build rules.
          -- Returns:
          --   - a map that says which rule to run to generate it (Map ModuleName RuleId)
          --   - for each rule, what its dependencies are, and what Action to run to execute it
          runHookHandle
            \ cabalBuildInfoStuff -> do
              runSmallIO $ runRulesM (rules preBuildRules cabalBuildInfoStuff)
        _ -> error $ "hooksExecutable: invalid hook name " ++ hookName

runPreBuildRules
  :: PreBuildComponentInputs
  -> ( PreBuildComponentInputs -> ActionId -> [ResolvedDependency] -> IO () )
    -- ^ how to run an individual action
  -> ( PreBuildComponentInputs -> IO ( Map ModuleName RuleId, Map RuleId Rule ) )
    -- ^ all pre-build rules
  -> IO ()
runPreBuildRules buildInfoStuff runAction getRules = do
  ( _modRules, ruleFromId ) <- getRules buildInfoStuff
  let
    ( ruleGraph, ruleFromVertex, _vertexIdFromRuleId ) =
      Graph.graphFromEdges
        [ ( rule, rId, ruleDeps )
        | ( rId, rule@( Rule { dependencies = allDeps } ) ) <- Map.assocs ruleFromId
        , let ruleDeps =
                mapMaybe
                  ( \case { RuleResult ( RuleResultRef { ruleId = i } ) -> Just i; ProjectFile {} -> Nothing} )
                   allDeps
        ]
    resolveDep :: RuleId -> Dependency -> IO ResolvedDependency
    resolveDep baseRuleId = \case
      ProjectFile fp -> do
        basePath <- error "TODO: look for fp in the search paths and find the base path" buildInfoStuff fp
        return (basePath, fp)
      RuleResult ( RuleResultRef { ruleId = depRuleId, ruleResultIndex = i } ) ->
        case Map.lookup depRuleId ruleFromId of
          Nothing -> error $ "runPreBuildRules: rule " ++ show baseRuleId ++ " depends on non-existent rule " ++ show depRuleId
          Just ( Rule { results = depResults }) ->
            case listToMaybe $ drop ( fromIntegral i ) depResults of
              Nothing -> error $ unlines
                [ "runPreBuildRules: rule " ++ show baseRuleId ++ " depends on output " ++ show i ++ "of rule " ++ show depRuleId ++ ","
                , "but that rule only has " ++ show (length depResults) ++ " outputs." ]
              Just res -> case res of
                AutogenFile fp -> return (error "autogenComponentModulesDir", fp)
                BuildFile fp -> return (error "componentBuildDir", fp)

  for_ ( Graph.reverseTopSort ruleGraph ) \ v -> do
    let ( Rule { actionId = actId, dependencies = deps }, rId, _ ) = ruleFromVertex v
    resolvedDeps <- traverse (resolveDep rId) deps
    runAction buildInfoStuff actId resolvedDeps

  -- On-demand recompilation: when some of the 'ProjectFile' inputs
  -- specified in the 'ruleFromId' map are modified:
  --   - rerun 'getRules' (as the dependency graph may have changed)
  --   - execute the part of the build graph that is now stale

-- | Run a hook executable, passing inputs via stdin
-- and getting results from stdout.
runHookHandle
  :: ( Binary inputs, Binary outputs )
  => ( inputs -> IO outputs )
  -- ^ Hook to run; inputs are passed via stdin
  -> IO ()
runHookHandle hook = do
  inputsData <- LBS.getContents
  let inputs = Binary.decode inputsData
  output <- hook inputs
  LBS.putStr (Binary.encode output)

--------------------------------------------------------------------------------
-- API functions

liftFresh :: Functor m => m a -> FreshT m a
liftFresh f = StateT $ \ s -> (,s) <$> f

hoist :: ( forall x. n x -> m x )
      -> FreshT n a -> FreshT m a
hoist h ( StateT f ) = StateT $ \ s -> h $ f s

registerRule :: Monad m => Rule -> FreshT m RuleId
registerRule rule =
  do { oldRules <- get
     ; let newId
             | Just (RuleId i, _) <- Map.lookupMax oldRules
             = RuleId (i+1)
             | otherwise
             = RuleId 1
     ; put $ Map.insert newId rule oldRules
     ; return newId
     }
